// https://microsoft.github.io/monaco-editor/playground.html

const files = 
    { "zapatos/schema.ts": "\n/* \n * generated by zapatos (v0.1.1): https://github.com/jawj/zapatos\n * generated on 2020-03-17T13:12:28.388Z\n * \n * MANUAL CHANGES ARE LIABLE TO GET OVERWRITTEN\n */\n\n  import {\n    JSONValue,\n    JSONArray,\n    DateString,\n    SQLFragment,\n    SQL,\n    GenericSQLExpression,\n    ColumnNames,\n    ColumnValues,\n    ParentColumn,\n    DefaultType,\n  } from \"./src/core\";\n\n\n/* === schema: public === */\n\n/* --- enums --- */\n\nexport type appleEnvironment = 'PROD' | 'Sandbox';\nexport namespace every {\n  export type appleEnvironment = ['PROD', 'Sandbox'];\n}\n\n/* --- tables --- */\n\nexport namespace appleTransactions {\n  export type Table = \"appleTransactions\";\n  export interface Selectable {\n    environment: appleEnvironment;\n    originalTransactionId: string;\n    accountId: number;\n    latestReceiptData: string | null;\n  };\n  export interface Insertable {\n    environment: appleEnvironment | SQLFragment;\n    originalTransactionId: string | SQLFragment;\n    accountId: number | SQLFragment;\n    latestReceiptData?: string | null | DefaultType | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace authors {\n  export type Table = \"authors\";\n  export interface Selectable {\n    id: number;\n    name: string;\n    isLiving: boolean | null;\n  };\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    isLiving?: boolean | null | DefaultType | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace books {\n  export type Table = \"books\";\n  export interface Selectable {\n    id: number;\n    authorId: number;\n    title: string | null;\n    createdAt: Date;\n    updatedAt: Date;\n  };\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    authorId: number | SQLFragment;\n    title?: string | null | DefaultType | SQLFragment;\n    createdAt?: Date | DateString | DefaultType | SQLFragment;\n    updatedAt?: Date | DateString | DefaultType | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace emailAuthentication {\n  export type Table = \"emailAuthentication\";\n  export interface Selectable {\n    email: string;\n    consecutiveFailedLogins: number;\n    lastFailedLogin: Date | null;\n  };\n  export interface Insertable {\n    email: string | SQLFragment;\n    consecutiveFailedLogins?: number | DefaultType | SQLFragment;\n    lastFailedLogin?: Date | DateString | null | DefaultType | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace employees {\n  export type Table = \"employees\";\n  export interface Selectable {\n    id: number;\n    name: string;\n    managerId: number | null;\n  };\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    managerId?: number | null | DefaultType | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace stores {\n  export type Table = \"stores\";\n  export interface Selectable {\n    id: number;\n    name: string;\n    geom: any;\n  };\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    geom: any | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace tags {\n  export type Table = \"tags\";\n  export interface Selectable {\n    tag: string;\n    bookId: number;\n  };\n  export interface Insertable {\n    tag: string | SQLFragment;\n    bookId: number | SQLFragment;\n  };\n  export interface Updatable extends Partial<Insertable> { };\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\n/* --- cross-table types --- */\n\nexport type Table = appleTransactions.Table | authors.Table | books.Table | emailAuthentication.Table | employees.Table | stores.Table | tags.Table;\nexport type Selectable = appleTransactions.Selectable | authors.Selectable | books.Selectable | emailAuthentication.Selectable | employees.Selectable | stores.Selectable | tags.Selectable;\nexport type Whereable = appleTransactions.Whereable | authors.Whereable | books.Whereable | emailAuthentication.Whereable | employees.Whereable | stores.Whereable | tags.Whereable;\nexport type Insertable = appleTransactions.Insertable | authors.Insertable | books.Insertable | emailAuthentication.Insertable | employees.Insertable | stores.Insertable | tags.Insertable;\nexport type Updatable = appleTransactions.Updatable | authors.Updatable | books.Updatable | emailAuthentication.Updatable | employees.Updatable | stores.Updatable | tags.Updatable;\nexport type Column = appleTransactions.Column | authors.Column | books.Column | emailAuthentication.Column | employees.Column | stores.Column | tags.Column;\nexport type AllTables = [appleTransactions.Table, authors.Table, books.Table, emailAuthentication.Table, employees.Table, stores.Table, tags.Table];\n\n\nexport type SelectableForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.Selectable :\n  T extends authors.Table ? authors.Selectable :\n  T extends books.Table ? books.Selectable :\n  T extends emailAuthentication.Table ? emailAuthentication.Selectable :\n  T extends employees.Table ? employees.Selectable :\n  T extends stores.Table ? stores.Selectable :\n  T extends tags.Table ? tags.Selectable :\n  Selectable;\n\nexport type WhereableForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.Whereable :\n  T extends authors.Table ? authors.Whereable :\n  T extends books.Table ? books.Whereable :\n  T extends emailAuthentication.Table ? emailAuthentication.Whereable :\n  T extends employees.Table ? employees.Whereable :\n  T extends stores.Table ? stores.Whereable :\n  T extends tags.Table ? tags.Whereable :\n  Whereable;\n\nexport type InsertableForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.Insertable :\n  T extends authors.Table ? authors.Insertable :\n  T extends books.Table ? books.Insertable :\n  T extends emailAuthentication.Table ? emailAuthentication.Insertable :\n  T extends employees.Table ? employees.Insertable :\n  T extends stores.Table ? stores.Insertable :\n  T extends tags.Table ? tags.Insertable :\n  Insertable;\n\nexport type UpdatableForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.Updatable :\n  T extends authors.Table ? authors.Updatable :\n  T extends books.Table ? books.Updatable :\n  T extends emailAuthentication.Table ? emailAuthentication.Updatable :\n  T extends employees.Table ? employees.Updatable :\n  T extends stores.Table ? stores.Updatable :\n  T extends tags.Table ? tags.Updatable :\n  Updatable;\n\nexport type ColumnForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.Column :\n  T extends authors.Table ? authors.Column :\n  T extends books.Table ? books.Column :\n  T extends emailAuthentication.Table ? emailAuthentication.Column :\n  T extends employees.Table ? employees.Column :\n  T extends stores.Table ? stores.Column :\n  T extends tags.Table ? tags.Column :\n  Column;\n\nexport type SQLForTable<T extends Table> = \n  T extends appleTransactions.Table ? appleTransactions.SQL :\n  T extends authors.Table ? authors.SQL :\n  T extends books.Table ? books.SQL :\n  T extends emailAuthentication.Table ? emailAuthentication.SQL :\n  T extends employees.Table ? employees.SQL :\n  T extends stores.Table ? stores.SQL :\n  T extends tags.Table ? tags.SQL :\n  SQL;\n\n", "zapatos/src/config.ts": "\nconst config = {  // defaults\n  transactionAttemptsMax: 5,\n  transactionRetryDelay: { minMs: 25, maxMs: 250 },\n  verbose: false,\n};\n\nexport type Config = typeof config;\nexport type NewConfig = Partial<Config>;\n\n/**\n * Get (a copy of) the current configuration.\n */\nexport const getConfig = () => Object.assign({}, config);\n\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport const setConfig = (newConfig: NewConfig) => Object.assign(config, newConfig);\n", "zapatos/src/core.ts": "import * as pg from 'pg';\n\nimport {\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\nimport { getConfig } from './config';\nimport { TxnClient } from './transaction';\n\n\n// === symbols, types, wrapper classes and shortcuts ===\n\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport const Default = Symbol('DEFAULT');\nexport type DefaultType = typeof Default;\n\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport const self = Symbol('self');\nexport type SelfType = typeof self;\n\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport const all = Symbol('all');\nexport type AllType = typeof all;\n\nexport type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport type JSONObject = { [k: string]: JSONValue };\nexport type JSONArray = JSONValue[];\n\n/**\n * Date represented as an ISO8601 string in JSON.\n */\nexport type DateString = string;\n\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value \n * at the appropriate position of the values array passed to pg  \n */\nexport class Parameter { constructor(public value: any) { } }\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter (`$1`, \n * `$2`, etc) and adds its wrapped value at the appropriate position of the values array \n * passed to pg\n */\nexport function param(x: any) { return new Parameter(x); }\n\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport class DangerousRawString { constructor(public value: string) { } }\n/**\n * Returns a `DangerousRawString` instance, wrapping a string. `DangerousRawString`\n * compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport function raw(x: string) { return new DangerousRawString(x); }\n\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or object. `ColumnNames` \n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT` \n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query, alongside \n * `ColumnValues`).\n */\nexport class ColumnNames<T> { constructor(public value: T) { } }\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object. `ColumnNames` \n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT` \n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query alongside \n * a `ColumnValues`).\n */\nexport function cols<T>(x: T) { return new ColumnNames<T>(x); }\n\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an `INSERT`, \n * `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport class ColumnValues<T> { constructor(public value: T) { } }\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to a \n * quoted, comma-separated list of object keys for use in an INSERT, UPDATE or UPSERT \n * query alongside a `ColumnNames`.\n */\nexport function vals<T>(x: T) { return new ColumnValues<T>(x); }\n\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport class ParentColumn { constructor(public value: Column) { } }\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to that \n * column name of the table of the parent query.\n */\nexport function parent(x: Column) { return new ParentColumn(x); }\n\nexport type GenericSQLExpression = SQLFragment<any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable> | Whereable | Column | GenericSQLExpression;\nexport type SQL = SQLExpression | SQLExpression[];\n\nexport type Queryable = pg.Pool | TxnClient<any>;\n\n\n// === SQL tagged template strings ===\n\ninterface SQLResultType {\n  text: string;\n  values: any[];\n};\n\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type argument \n * defines what interpolated value types are allowed. The second defines what type the \n * `SQLFragment` produces, where relevant (i.e. when calling `.run(...)` on it, or using \n * it as the value of an `extras` object).\n */\nexport function sql<T = SQL, RunResult = pg.QueryResult['rows']>(literals: TemplateStringsArray, ...expressions: T[]) {\n  return new SQLFragment<RunResult>(Array.prototype.slice.apply(literals), expressions);\n}\n\nexport class SQLFragment<RunResult = pg.QueryResult['rows']> {\n\n  /**\n   * When calling `run`, this function is applied to the object returned by `pg` to \n   * produce the result that is returned. By default, the `rows` array is returned — i.e.\n   * `(qr) => qr.rows` — but some shortcut functions alter this in order to match their \n   * declared `RunResult` type.\n   */\n  runResultTransform: (qr: pg.QueryResult) => any = (qr) => qr.rows;\n\n  parentTable?: string = undefined;  // used for nested shortcut select queries\n\n  constructor(private literals: string[], private expressions: SQLExpression[]) { }\n\n  /**\n   * Compile and run this query using the provided database connection. What's returned \n   * is piped via `runResultTransform` before being returned.\n   * @param queryable A database client or pool\n   */\n  async run(queryable: Queryable): Promise<RunResult> {\n    const query = this.compile();\n    if (getConfig().verbose) console.log(query);\n    const qr = await queryable.query(query);\n    return this.runResultTransform(qr);\n  }\n\n  /**\n   * Compile this query, returning a `{ text: string, values: any[] }` object that could \n   * be passed to the `pg` query function. Arguments are generally only passed when the \n   * function calls itself recursively.\n   */\n  compile(result: SQLResultType = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    result.text += this.literals[0];\n    for (let i = 1, len = this.literals.length; i < len; i++) {\n      this.compileExpression(this.expressions[i - 1], result, parentTable, currentColumn);\n      result.text += this.literals[i];\n    }\n    return result;\n  }\n\n  compileExpression(expression: SQL, result: SQLResultType = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    if (expression instanceof SQLFragment) {\n      // another SQL fragment? recursively compile this one\n      expression.compile(result, parentTable, currentColumn);\n\n    } else if (typeof expression === 'string') {\n      // if it's a string, it should be a x.Table or x.Columns type, so just needs quoting\n      result.text += expression.charAt(0) === '\"' ? expression : `\"${expression}\"`;\n\n    } else if (expression instanceof DangerousRawString) {\n      // Little Bobby Tables passes straight through ...\n      result.text += expression.value;\n\n    } else if (Array.isArray(expression)) {\n      // an array's elements are compiled one by one -- note that an empty array can be used as a non-value\n      for (let i = 0, len = expression.length; i < len; i++) this.compileExpression(expression[i], result, parentTable, currentColumn);\n\n    } else if (expression instanceof Parameter) {\n      // parameters become placeholders, and a corresponding entry in the values array\n      result.values.push(expression.value);\n      result.text += '$' + String(result.values.length);  // 1-based indexing\n\n    } else if (expression === Default) {\n      // a column default\n      result.text += 'DEFAULT';\n\n    } else if (expression === self) {\n      // alias to the latest column, if applicable\n      if (!currentColumn) throw new Error(`The 'self' column alias has no meaning here`);\n      result.text += `\"${currentColumn}\"`;\n\n    } else if (expression instanceof ParentColumn) {\n      // alias to the parent table (plus supplied column name) of a nested query, if applicable\n      if (!parentTable) throw new Error(`The 'parent' table alias has no meaning here`);\n      result.text += `\"${parentTable}\".\"${expression.value}\"`;\n\n    } else if (expression instanceof ColumnNames) {\n      // a ColumnNames-wrapped object -> quoted names in a repeatable order\n      // or: a ColumnNames-wrapped array\n      const columnNames = Array.isArray(expression.value) ? expression.value :\n        Object.keys(expression.value).sort();\n      result.text += columnNames.map(k => `\"${k}\"`).join(', ');\n\n    } else if (expression instanceof ColumnValues) {\n      // a ColumnValues-wrapped object -> values (in above order) are punted as SQL fragments or parameters\n      const\n        columnNames = <Column[]>Object.keys(expression.value).sort(),\n        columnValues = columnNames.map(k => (<any>expression.value)[k]);\n\n      for (let i = 0, len = columnValues.length; i < len; i++) {\n        const\n          columnName = columnNames[i],\n          columnValue = columnValues[i];\n        if (i > 0) result.text += ', ';\n        if (columnValue instanceof SQLFragment || columnValue === Default) this.compileExpression(columnValue, result, parentTable, columnName);\n        else this.compileExpression(new Parameter(columnValue), result, parentTable, columnName);\n      }\n\n    } else if (typeof expression === 'object') {\n      // must be a Whereable object, so put together a WHERE clause\n      const columnNames = <Column[]>Object.keys(expression).sort();\n\n      if (columnNames.length) {  // if the object is not empty\n        result.text += '(';\n        for (let i = 0, len = columnNames.length; i < len; i++) {\n          const\n            columnName = columnNames[i],\n            columnValue = (<any>expression)[columnName];\n          if (i > 0) result.text += ' AND ';\n          if (columnValue instanceof SQLFragment) {\n            result.text += '(';\n            this.compileExpression(columnValue, result, parentTable, columnName);\n            result.text += ')';\n\n          } else {\n            result.text += `\"${columnName}\" = `;\n            this.compileExpression(columnValue instanceof ParentColumn ? columnValue : new Parameter(columnValue),\n              result, parentTable, columnName);\n          }\n        }\n        result.text += ')';\n\n      } else {\n        // or if it is empty, it should always match\n        result.text += 'TRUE';\n      }\n\n    } else {\n      throw new Error(`Alien object while interpolating SQL: ${expression}`);\n    }\n  }\n}\n\n\n", "zapatos/src/index.ts": "\nexport * from './core';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * from './config';\n", "zapatos/src/pgErrors.ts": "\ninterface Error {\n  code?: string;\n}\n\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]) {\n  const { code } = err;\n  if (!code || code.length !== 5) return false;\n  return types.some(type => code.startsWith(pgErrors[type]));\n}\n\nconst pgErrors = {\n  SuccessfulCompletion: \"00\",\n  Warning: \"01\",\n  NoData: \"02\",\n  SqlStatementNotYetComplete: \"03\",\n  ConnectionException: \"08\",\n  TriggeredActionException: \"09\",\n  FeatureNotSupported: \"0A\",\n  InvalidTransactionInitiation: \"0B\",\n  LocatorException: \"0F\",\n  InvalidGrantor: \"0L\",\n  InvalidRoleSpecification: \"0P\",\n  DiagnosticsException: \"0Z\",\n  CaseNotFound: \"20\",\n  CardinalityViolation: \"21\",\n  DataException: \"22\",\n  IntegrityConstraintViolation: \"23\",\n  InvalidCursorState: \"24\",\n  InvalidTransactionState: \"25\",\n  InvalidSqlStatementName: \"26\",\n  TriggeredDataChangeViolation: \"27\",\n  InvalidAuthorizationSpecification: \"28\",\n  DependentPrivilegeDescriptorsStillExist: \"2B\",\n  InvalidTransactionTermination: \"2D\",\n  SqlRoutineException: \"2F\",\n  InvalidCursorName: \"34\",\n  ExternalRoutineException: \"38\",\n  ExternalRoutineInvocationException: \"39\",\n  SavepointException: \"3B\",\n  InvalidCatalogName: \"3D\",\n  InvalidSchemaName: \"3F\",\n  TransactionRollback: \"40\",\n  SyntaxErrorOrAccessRuleViolation: \"42\",\n  WithCheckOptionViolation: \"44\",\n  InsufficientResources: \"53\",\n  DiskFull: \"53\",\n  OutOfMemory: \"53\",\n  TooManyConnections: \"53\",\n  ConfigurationLimitExceeded: \"53\",\n  ProgramLimitExceeded: \"54\",\n  ObjectNotInPrerequisiteState: \"55\",\n  OperatorIntervention: \"57\",\n  SystemError: \"58\",\n  SnapshotTooOld: \"72\",\n  ConfigFileError: \"F0\",\n  FdwError: \"HV\",\n  PlpgsqlError: \"P0\",\n  InternalError: \"XX\",\n  // specific errors from here\n  SuccessfulCompletion_SuccessfulCompletion: \"00000\",\n  Warning_Warning: \"01000\",\n  Warning_NullValueEliminatedInSetFunction: \"01003\",\n  Warning_StringDataRightTruncation: \"01004\",\n  Warning_PrivilegeNotRevoked: \"01006\",\n  Warning_PrivilegeNotGranted: \"01007\",\n  Warning_ImplicitZeroBitPadding: \"01008\",\n  Warning_DynamicResultSetsReturned: \"0100C\",\n  Warning_DeprecatedFeature: \"01P01\",\n  NoData_NoData: \"02000\",\n  NoData_NoAdditionalDynamicResultSetsReturned: \"02001\",\n  SqlStatementNotYetComplete_SqlStatementNotYetComplete: \"03000\",\n  ConnectionException_ConnectionException: \"08000\",\n  ConnectionException_SqlclientUnableToEstablishSqlconnection: \"08001\",\n  ConnectionException_ConnectionDoesNotExist: \"08003\",\n  ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: \"08004\",\n  ConnectionException_ConnectionFailure: \"08006\",\n  ConnectionException_TransactionResolutionUnknown: \"08007\",\n  ConnectionException_ProtocolViolation: \"08P01\",\n  TriggeredActionException_TriggeredActionException: \"09000\",\n  FeatureNotSupported_FeatureNotSupported: \"0A000\",\n  InvalidTransactionInitiation_InvalidTransactionInitiation: \"0B000\",\n  LocatorException_LocatorException: \"0F000\",\n  LocatorException_InvalidLocatorSpecification: \"0F001\",\n  InvalidGrantor_InvalidGrantor: \"0L000\",\n  InvalidGrantor_InvalidGrantOperation: \"0LP01\",\n  InvalidRoleSpecification_InvalidRoleSpecification: \"0P000\",\n  DiagnosticsException_DiagnosticsException: \"0Z000\",\n  DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: \"0Z002\",\n  CaseNotFound_CaseNotFound: \"20000\",\n  CardinalityViolation_CardinalityViolation: \"21000\",\n  DataException_DataException: \"22000\",\n  DataException_StringDataRightTruncation: \"22001\",\n  DataException_NullValueNoIndicatorParameter: \"22002\",\n  DataException_NumericValueOutOfRange: \"22003\",\n  DataException_NullValueNotAllowed: \"22004\",\n  DataException_ErrorInAssignment: \"22005\",\n  DataException_InvalidDatetimeFormat: \"22007\",\n  DataException_DatetimeFieldOverflow: \"22008\",\n  DataException_InvalidTimeZoneDisplacementValue: \"22009\",\n  DataException_EscapeCharacterConflict: \"2200B\",\n  DataException_InvalidUseOfEscapeCharacter: \"2200C\",\n  DataException_InvalidEscapeOctet: \"2200D\",\n  DataException_ZeroLengthCharacterString: \"2200F\",\n  DataException_MostSpecificTypeMismatch: \"2200G\",\n  DataException_SequenceGeneratorLimitExceeded: \"2200H\",\n  DataException_NotAnXmlDocument: \"2200L\",\n  DataException_InvalidXmlDocument: \"2200M\",\n  DataException_InvalidXmlContent: \"2200N\",\n  DataException_InvalidXmlComment: \"2200S\",\n  DataException_InvalidXmlProcessingInstruction: \"2200T\",\n  DataException_InvalidIndicatorParameterValue: \"22010\",\n  DataException_SubstringError: \"22011\",\n  DataException_DivisionByZero: \"22012\",\n  DataException_InvalidPrecedingOrFollowingSize: \"22013\",\n  DataException_InvalidArgumentForNtileFunction: \"22014\",\n  DataException_IntervalFieldOverflow: \"22015\",\n  DataException_InvalidArgumentForNthValueFunction: \"22016\",\n  DataException_InvalidCharacterValueForCast: \"22018\",\n  DataException_InvalidEscapeCharacter: \"22019\",\n  DataException_InvalidRegularExpression: \"2201B\",\n  DataException_InvalidArgumentForLogarithm: \"2201E\",\n  DataException_InvalidArgumentForPowerFunction: \"2201F\",\n  DataException_InvalidArgumentForWidthBucketFunction: \"2201G\",\n  DataException_InvalidRowCountInLimitClause: \"2201W\",\n  DataException_InvalidRowCountInResultOffsetClause: \"2201X\",\n  DataException_CharacterNotInRepertoire: \"22021\",\n  DataException_IndicatorOverflow: \"22022\",\n  DataException_InvalidParameterValue: \"22023\",\n  DataException_UnterminatedCString: \"22024\",\n  DataException_InvalidEscapeSequence: \"22025\",\n  DataException_StringDataLengthMismatch: \"22026\",\n  DataException_TrimError: \"22027\",\n  DataException_ArraySubscriptError: \"2202E\",\n  DataException_InvalidTablesampleRepeat: \"2202G\",\n  DataException_InvalidTablesampleArgument: \"2202H\",\n  DataException_FloatingPointException: \"22P01\",\n  DataException_InvalidTextRepresentation: \"22P02\",\n  DataException_InvalidBinaryRepresentation: \"22P03\",\n  DataException_BadCopyFileFormat: \"22P04\",\n  DataException_UntranslatableCharacter: \"22P05\",\n  DataException_NonstandardUseOfEscapeCharacter: \"22P06\",\n  IntegrityConstraintViolation_IntegrityConstraintViolation: \"23000\",\n  IntegrityConstraintViolation_RestrictViolation: \"23001\",\n  IntegrityConstraintViolation_NotNullViolation: \"23502\",\n  IntegrityConstraintViolation_ForeignKeyViolation: \"23503\",\n  IntegrityConstraintViolation_UniqueViolation: \"23505\",\n  IntegrityConstraintViolation_CheckViolation: \"23514\",\n  IntegrityConstraintViolation_ExclusionViolation: \"23P01\",\n  InvalidCursorState_InvalidCursorState: \"24000\",\n  InvalidTransactionState_InvalidTransactionState: \"25000\",\n  InvalidTransactionState_ActiveSqlTransaction: \"25001\",\n  InvalidTransactionState_BranchTransactionAlreadyActive: \"25002\",\n  InvalidTransactionState_InappropriateAccessModeForBranchTransaction: \"25003\",\n  InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: \"25004\",\n  InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: \"25005\",\n  InvalidTransactionState_ReadOnlySqlTransaction: \"25006\",\n  InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: \"25007\",\n  InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: \"25008\",\n  InvalidTransactionState_NoActiveSqlTransaction: \"25P01\",\n  InvalidTransactionState_InFailedSqlTransaction: \"25P02\",\n  InvalidTransactionState_IdleInTransactionSessionTimeout: \"25P03\",\n  InvalidSqlStatementName_InvalidSqlStatementName: \"26000\",\n  TriggeredDataChangeViolation_TriggeredDataChangeViolation: \"27000\",\n  InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: \"28000\",\n  InvalidAuthorizationSpecification_InvalidPassword: \"28P01\",\n  DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: \"2B000\",\n  DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: \"2BP01\",\n  InvalidTransactionTermination_InvalidTransactionTermination: \"2D000\",\n  SqlRoutineException_SqlRoutineException: \"2F000\",\n  SqlRoutineException_ModifyingSqlDataNotPermitted: \"2F002\",\n  SqlRoutineException_ProhibitedSqlStatementAttempted: \"2F003\",\n  SqlRoutineException_ReadingSqlDataNotPermitted: \"2F004\",\n  SqlRoutineException_FunctionExecutedNoReturnStatement: \"2F005\",\n  InvalidCursorName_InvalidCursorName: \"34000\",\n  ExternalRoutineException_ExternalRoutineException: \"38000\",\n  ExternalRoutineException_ContainingSqlNotPermitted: \"38001\",\n  ExternalRoutineException_ModifyingSqlDataNotPermitted: \"38002\",\n  ExternalRoutineException_ProhibitedSqlStatementAttempted: \"38003\",\n  ExternalRoutineException_ReadingSqlDataNotPermitted: \"38004\",\n  ExternalRoutineInvocationException_ExternalRoutineInvocationException: \"39000\",\n  ExternalRoutineInvocationException_InvalidSqlstateReturned: \"39001\",\n  ExternalRoutineInvocationException_NullValueNotAllowed: \"39004\",\n  ExternalRoutineInvocationException_TriggerProtocolViolated: \"39P01\",\n  ExternalRoutineInvocationException_SrfProtocolViolated: \"39P02\",\n  ExternalRoutineInvocationException_EventTriggerProtocolViolated: \"39P03\",\n  SavepointException_SavepointException: \"3B000\",\n  SavepointException_InvalidSavepointSpecification: \"3B001\",\n  InvalidCatalogName_InvalidCatalogName: \"3D000\",\n  InvalidSchemaName_InvalidSchemaName: \"3F000\",\n  TransactionRollback_TransactionRollback: \"40000\",\n  TransactionRollback_SerializationFailure: \"40001\",\n  TransactionRollback_TransactionIntegrityConstraintViolation: \"40002\",\n  TransactionRollback_StatementCompletionUnknown: \"40003\",\n  TransactionRollback_DeadlockDetected: \"40P01\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: \"42000\",\n  SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: \"42501\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxError: \"42601\",\n  SyntaxErrorOrAccessRuleViolation_InvalidName: \"42602\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: \"42611\",\n  SyntaxErrorOrAccessRuleViolation_NameTooLong: \"42622\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateColumn: \"42701\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: \"42702\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedColumn: \"42703\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedObject: \"42704\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateObject: \"42710\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateAlias: \"42712\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateFunction: \"42723\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: \"42725\",\n  SyntaxErrorOrAccessRuleViolation_GroupingError: \"42803\",\n  SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: \"42804\",\n  SyntaxErrorOrAccessRuleViolation_WrongObjectType: \"42809\",\n  SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: \"42830\",\n  SyntaxErrorOrAccessRuleViolation_CannotCoerce: \"42846\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedFunction: \"42883\",\n  SyntaxErrorOrAccessRuleViolation_GeneratedAlways: \"428C9\",\n  SyntaxErrorOrAccessRuleViolation_ReservedName: \"42939\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedTable: \"42P01\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedParameter: \"42P02\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateCursor: \"42P03\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: \"42P04\",\n  SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: \"42P05\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateSchema: \"42P06\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateTable: \"42P07\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: \"42P08\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: \"42P09\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: \"42P10\",\n  SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: \"42P11\",\n  SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: \"42P12\",\n  SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: \"42P13\",\n  SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: \"42P14\",\n  SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: \"42P15\",\n  SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: \"42P16\",\n  SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: \"42P17\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: \"42P18\",\n  SyntaxErrorOrAccessRuleViolation_InvalidRecursion: \"42P19\",\n  SyntaxErrorOrAccessRuleViolation_WindowingError: \"42P20\",\n  SyntaxErrorOrAccessRuleViolation_CollationMismatch: \"42P21\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: \"42P22\",\n  WithCheckOptionViolation_WithCheckOptionViolation: \"44000\",\n  InsufficientResources_InsufficientResources: \"53000\",\n  InsufficientResources_DiskFull: \"53100\",\n  InsufficientResources_OutOfMemory: \"53200\",\n  InsufficientResources_TooManyConnections: \"53300\",\n  InsufficientResources_ConfigurationLimitExceeded: \"53400\",\n  ProgramLimitExceeded_ProgramLimitExceeded: \"54000\",\n  ProgramLimitExceeded_StatementTooComplex: \"54001\",\n  ProgramLimitExceeded_TooManyColumns: \"54011\",\n  ProgramLimitExceeded_TooManyArguments: \"54023\",\n  ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: \"55000\",\n  ObjectNotInPrerequisiteState_ObjectInUse: \"55006\",\n  ObjectNotInPrerequisiteState_CantChangeRuntimeParam: \"55P02\",\n  ObjectNotInPrerequisiteState_LockNotAvailable: \"55P03\",\n  OperatorIntervention_OperatorIntervention: \"57000\",\n  OperatorIntervention_QueryCanceled: \"57014\",\n  OperatorIntervention_AdminShutdown: \"57P01\",\n  OperatorIntervention_CrashShutdown: \"57P02\",\n  OperatorIntervention_CannotConnectNow: \"57P03\",\n  OperatorIntervention_DatabaseDropped: \"57P04\",\n  SystemError_SystemError: \"58000\",\n  SystemError_IoError: \"58030\",\n  SystemError_UndefinedFile: \"58P01\",\n  SystemError_DuplicateFile: \"58P02\",\n  SnapshotTooOld_SnapshotTooOld: \"72000\",\n  ConfigFileError_ConfigFileError: \"F0000\",\n  ConfigFileError_LockFileExists: \"F0001\",\n  FdwError_FdwError: \"HV000\",\n  FdwError_FdwOutOfMemory: \"HV001\",\n  FdwError_FdwDynamicParameterValueNeeded: \"HV002\",\n  FdwError_FdwInvalidDataType: \"HV004\",\n  FdwError_FdwColumnNameNotFound: \"HV005\",\n  FdwError_FdwInvalidDataTypeDescriptors: \"HV006\",\n  FdwError_FdwInvalidColumnName: \"HV007\",\n  FdwError_FdwInvalidColumnNumber: \"HV008\",\n  FdwError_FdwInvalidUseOfNullPointer: \"HV009\",\n  FdwError_FdwInvalidStringFormat: \"HV00A\",\n  FdwError_FdwInvalidHandle: \"HV00B\",\n  FdwError_FdwInvalidOptionIndex: \"HV00C\",\n  FdwError_FdwInvalidOptionName: \"HV00D\",\n  FdwError_FdwOptionNameNotFound: \"HV00J\",\n  FdwError_FdwReplyHandle: \"HV00K\",\n  FdwError_FdwUnableToCreateExecution: \"HV00L\",\n  FdwError_FdwUnableToCreateReply: \"HV00M\",\n  FdwError_FdwUnableToEstablishConnection: \"HV00N\",\n  FdwError_FdwNoSchemas: \"HV00P\",\n  FdwError_FdwSchemaNotFound: \"HV00Q\",\n  FdwError_FdwTableNotFound: \"HV00R\",\n  FdwError_FdwFunctionSequenceError: \"HV010\",\n  FdwError_FdwTooManyHandles: \"HV014\",\n  FdwError_FdwInconsistentDescriptorInformation: \"HV021\",\n  FdwError_FdwInvalidAttributeValue: \"HV024\",\n  FdwError_FdwInvalidStringLengthOrBufferLength: \"HV090\",\n  FdwError_FdwInvalidDescriptorFieldIdentifier: \"HV091\",\n  PlpgsqlError_PlpgsqlError: \"P0000\",\n  PlpgsqlError_RaiseException: \"P0001\",\n  PlpgsqlError_NoDataFound: \"P0002\",\n  PlpgsqlError_TooManyRows: \"P0003\",\n  PlpgsqlError_AssertFailure: \"P0004\",\n  InternalError_InternalError: \"XX000\",\n  InternalError_DataCorrupted: \"XX001\",\n  InternalError_IndexCorrupted: \"XX002\",\n}\n", "zapatos/src/shortcuts.ts": "\nimport {\n  SelectableForTable,\n  WhereableForTable,\n  InsertableForTable,\n  UpdatableForTable,\n  ColumnForTable,\n  SQLForTable,\n  Insertable,\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\nimport {\n  AllType,\n  all,\n  DateString,\n  SQL,\n  SQLFragment,\n  sql,\n  cols,\n  vals,\n  raw,\n} from './core';\n\nimport { completeKeysWithDefault, mapWithSeparator } from './utils';\n\ntype JSONSelectableForTable<T extends Table> = { [K in keyof SelectableForTable<T>]:\n  Date extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date> | DateString :\n  Date[] extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date[]> | DateString[] :\n  SelectableForTable<T>[K]\n};\n\n\n/* === insert === */\n\ninterface InsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>): SQLFragment<JSONSelectableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[]): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport const insert: InsertSignatures = function\n  (table: Table, values: Insertable | Insertable[]): SQLFragment<any> {\n\n  const\n    completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n    colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues),\n    valuesSQL = Array.isArray(completedValues) ?\n      mapWithSeparator(completedValues as Insertable[], sql<SQL>`, `, v => sql<SQL>`(${vals(v)})`) :\n      sql<SQL>`(${vals(completedValues)})`,\n    query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} RETURNING to_jsonb(${table}.*) AS result`;\n\n  query.runResultTransform = Array.isArray(completedValues) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n}\n\n\n/* === upsert === */\n\ninterface UpsertAction { $action: 'INSERT' | 'UPDATE' };\ntype UpsertReturnableForTable<T extends Table> = JSONSelectableForTable<T> & UpsertAction;\n\ninterface UpsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>, uniqueCols: ColumnForTable<T> | ColumnForTable<T>[], noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[], uniqueCols: ColumnForTable<T> | ColumnForTable<T>[], noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>[]>;\n}\n\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted or updated\n * @param uniqueCols A `UNIQUE`-indexed column (or array thereof) that determines \n * whether this is an `UPDATE` (when there's a matching existing value) or an `INSERT` \n * (when there isn't)\n * @param noNullUpdateCols Optionally, a column (or array thereof) that should not be \n * overwritten with `NULL` values during an update\n */\nexport const upsert: UpsertSignatures = function\n  (table: Table, values: Insertable | Insertable[], uniqueCols: Column | Column[], noNullUpdateCols: Column | Column[] = []): SQLFragment<any> {\n\n  if (!Array.isArray(uniqueCols)) uniqueCols = [uniqueCols];\n  if (!Array.isArray(noNullUpdateCols)) noNullUpdateCols = [noNullUpdateCols];\n\n  const\n    completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n    colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues),\n    valuesSQL = Array.isArray(completedValues) ?\n      mapWithSeparator(completedValues as Insertable[], sql`, `, v => sql`(${vals(v)})`) :\n      sql`(${vals(completedValues)})`,\n    nonUniqueCols = (Object.keys(Array.isArray(completedValues) ? completedValues[0] : completedValues) as Column[])\n      .filter(v => !uniqueCols.includes(v)),\n    uniqueColsSQL = mapWithSeparator(uniqueCols.slice().sort(), sql`, `, c => c),\n    updateColsSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c => c),\n    updateValuesSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c =>\n      noNullUpdateCols.includes(c) ? sql`CASE WHEN EXCLUDED.${c} IS NULL THEN ${table}.${c} ELSE EXCLUDED.${c} END` : sql`EXCLUDED.${c}`);\n\n  // the added-on $action = 'INSERT' | 'UPDATE' key takes after SQL Server's approach to MERGE\n  // (and on the use of xmax for this purpose, see: https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x)\n\n  const query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} ON CONFLICT (${uniqueColsSQL}) DO UPDATE SET (${updateColsSQL}) = ROW(${updateValuesSQL}) RETURNING to_jsonb(${table}.*) || jsonb_build_object('$action', CASE xmax WHEN 0 THEN 'INSERT' ELSE 'UPDATE' END) AS result`;\n\n  query.runResultTransform = Array.isArray(completedValues) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n}\n\n\n/* === update === */\n\ninterface UpdateSignatures {\n  <T extends Table>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport const update: UpdateSignatures = function (\n  table: Table,\n  values: Updatable,\n  where: Whereable | SQLFragment): SQLFragment {\n\n  // note: the ROW() constructor below is required in Postgres 10+ if we're updating a single column\n  // more info: https://www.postgresql-archive.org/Possible-regression-in-UPDATE-SET-lt-column-list-gt-lt-row-expression-gt-with-just-one-single-column0-td5989074.html\n\n  const query = sql<SQL>`UPDATE ${table} SET (${cols(values)}) = ROW(${vals(values)}) WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n}\n\n\n/* === delete === */\n\nexport interface DeleteSignatures {\n  <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `DELETE` query `SQLFragment` (sadly, plain 'delete' is a reserved word).\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport const deletes: DeleteSignatures = function\n  (table: Table, where: Whereable | SQLFragment): SQLFragment {\n\n  const query = sql<SQL>`DELETE FROM ${table} WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n}\n\n\n/* === truncate === */\n\ntype TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ntype TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\n\ninterface TruncateSignatures {\n  (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or 'RESTRICT'/'CASCADE'\n */\nexport const truncate: TruncateSignatures = function\n  (table: Table | Table[], ...opts: string[]): SQLFragment<undefined> {\n\n  if (!Array.isArray(table)) table = [table];\n  const\n    tables = mapWithSeparator(table, sql`, `, t => t),\n    query = sql<SQL, undefined>`TRUNCATE ${tables}${raw((opts.length ? ' ' : '') + opts.join(' '))}`;\n\n  return query;\n}\n\n\n/* === select === */\n\ninterface OrderSpecForTable<T extends Table> {\n  by: SQLForTable<T>,\n  direction: 'ASC' | 'DESC',\n  nulls?: 'FIRST' | 'LAST',\n}\n\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap> {\n  order?: OrderSpecForTable<T>[];\n  limit?: number;\n  offset?: number;\n  columns?: C;\n  extras?: E,\n  lateral?: L;\n  alias?: string;\n}\n\nexport interface SQLFragmentsMap { [k: string]: SQLFragment<any> };\nexport type PromisedType<P> = P extends Promise<infer U> ? U : never;\nexport type PromisedSQLFragmentReturnType<R extends SQLFragment<any>> = PromisedType<ReturnType<R['run']>>;\nexport type PromisedSQLFragmentReturnTypeMap<L extends SQLFragmentsMap> = { [K in keyof L]: PromisedSQLFragmentReturnType<L[K]> };\n\nexport type JSONOnlyColsForTable<T extends Table, C extends any[] /* TS can't manage being more specific here */> = Pick<JSONSelectableForTable<T>, C[number]>;\n\ntype BaseSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[]> = C extends undefined ? JSONSelectableForTable<T> : JSONOnlyColsForTable<T, C>;\n\ntype EnhancedSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap> =\n  L extends undefined ?\n  (E extends undefined ? BaseSelectReturnTypeForTable<T, C> : BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<E>) :\n  (E extends undefined ?\n    BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<L> :\n    BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<L> & PromisedSQLFragmentReturnTypeMap<E>);\n\nexport type FullSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap, M extends SelectResultMode> =\n  M extends SelectResultMode.Many ? EnhancedSelectReturnTypeForTable<T, C, L, E>[] :\n  M extends SelectResultMode.One ? EnhancedSelectReturnTypeForTable<T, C, L, E> | undefined : number;\n\nexport enum SelectResultMode { Many, One, Count };\n\nexport interface SelectSignatures {\n  <T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap, M extends SelectResultMode = SelectResultMode.Many> (\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n    mode?: M,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other `select`/\n * `selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. Keys (all optional) are: \n * * `columns` — an array of column names: only these columns will be returned\n * * `order` — an array of `OrderSpec` objects, such as `{ by: 'column', direction: 'ASC' \n * }`  \n * * `limit` and `offset` — numbers: apply this limit and offset to the query\n * * `lateral` — an object mapping key(s) to nested `select`/`selectOne`/`count` queries \n * to be `LATERAL JOIN`ed\n * * `alias` — table alias (string): required if using `lateral` to join a table to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived \n * quantities can be included in the JSON result\n * @param mode Used internally by `selectOne` and `count`\n */\nexport const select: SelectSignatures = function (\n  table: Table,\n  where: Whereable | SQLFragment | AllType = all,\n  options: SelectOptionsForTable<Table, ColumnForTable<Table>[], SQLFragmentsMap, SQLFragmentsMap> = {},\n  mode: SelectResultMode = SelectResultMode.Many,\n) {\n\n  const\n    allOptions = mode === SelectResultMode.One ? Object.assign({}, options, { limit: 1 }) : options,\n    aliasedTable = allOptions.alias || table,\n    tableAliasSQL = aliasedTable === table ? [] : sql` AS ${aliasedTable}`,\n    colsSQL = mode === SelectResultMode.Count ?\n      (allOptions.columns ? sql`count(${cols(allOptions.columns)})` : sql`count(${aliasedTable}.*)`) :\n      allOptions.columns ?\n        sql`jsonb_build_object(${mapWithSeparator(allOptions.columns, sql`, `, c => raw(`'${c}', \"${c}\"`))})` :\n        sql`to_jsonb(${aliasedTable}.*)`,\n    colsLateralSQL = allOptions.lateral === undefined ? [] :\n      sql` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(allOptions.lateral), sql`, `, k => raw(`'${k}', \"cj_${k}\".result`))})`,\n    colsExtraSQL = allOptions.extras === undefined ? [] :\n      sql` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(allOptions.extras), sql`, `, k => [raw(`'${k}', `), allOptions.extras![k]])})`,\n    allColsSQL = sql`${colsSQL}${colsLateralSQL}${colsExtraSQL}`,\n    whereSQL = where === all ? [] : [sql` WHERE `, where],\n    orderSQL = !allOptions.order ? [] :\n      [sql` ORDER BY `, ...mapWithSeparator(allOptions.order, sql`, `, o =>\n        sql`${o.by} ${raw(o.direction)}${o.nulls ? sql` NULLS ${raw(o.nulls)}` : []}`)],\n    limitSQL = allOptions.limit === undefined ? [] : sql` LIMIT ${raw(String(allOptions.limit))}`,\n    offsetSQL = allOptions.offset === undefined ? [] : sql` OFFSET ${raw(String(allOptions.offset))}`,\n    lateralSQL = allOptions.lateral === undefined ? [] : Object.keys(allOptions.lateral).map(k => {\n      const subQ = allOptions.lateral![k];\n      subQ.parentTable = aliasedTable;  // enables db.parent('column') in nested query Wherables\n      return sql<SQL>` LEFT JOIN LATERAL (${subQ}) AS ${raw(`\"cj_${k}\"`)} ON true`;\n    });\n\n  const\n    rowsQuery = sql<SQL, any>`SELECT ${allColsSQL} AS result FROM ${table}${tableAliasSQL}${lateralSQL}${whereSQL}${orderSQL}${limitSQL}${offsetSQL}`,\n    query = mode !== SelectResultMode.Many ? rowsQuery :\n      // we need the aggregate to sit in a sub-SELECT in order to keep ORDER and LIMIT working as usual\n      sql<SQL, any>`SELECT coalesce(jsonb_agg(result), '[]') AS result FROM (${rowsQuery}) AS ${raw(`\"sq_${aliasedTable}\"`)}`;\n\n  query.runResultTransform = mode === SelectResultMode.Count ?\n    // note: pg deliberately returns strings for int8 in case 64-bit numbers overflow\n    // (see https://github.com/brianc/node-pg-types#use), but we assume counts aren't that big\n    (qr) => Number(qr.rows[0].result) :\n    (qr) => qr.rows[0]?.result;\n\n  return query;\n}\n\n\n/* === selectOne === */\n\nexport interface SelectOneSignatures {\n  <T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap>(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or \n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with other \n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectOne: SelectOneSignatures = function (\n  table: any,\n  where: any,\n  options: any = {},\n) {\n  // you might argue that 'selectOne' offers little that you can't get with destructuring assignment \n  // and plain 'select' -- e.g. let [x] = async select(...).run(pool); -- but a thing that is definitely worth \n  // having is '| undefined' in the return signature, because the result of indexing never includes undefined\n  // (see e.g. https://github.com/Microsoft/TypeScript/issues/13778)\n\n  return select(table, where, options, SelectResultMode.One);\n}\n\n\n/* === count === */\n\nexport interface CountSignatures {\n  <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: { columns?: ColumnForTable<T>[], alias?: string }): SQLFragment<number>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be nested in \n * other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted, or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport const count: CountSignatures = function (\n  table: any,\n  where: any,\n  options?: any,\n) {\n\n  return select(table, where, options, SelectResultMode.Count);\n}\n", "zapatos/src/transaction.ts": "import * as pg from 'pg';\nimport { isDatabaseError } from './pgErrors';\nimport { wait } from './utils';\nimport { sql, raw } from './core';\nimport { getConfig } from \"./config\";\n\n\nexport enum Isolation {\n  // these are the only meaningful values in Postgres: \n  // see https://www.postgresql.org/docs/11/sql-set-transaction.html\n  Serializable = \"SERIALIZABLE\",\n  RepeatableRead = \"REPEATABLE READ\",\n  ReadCommitted = \"READ COMMITTED\",\n  SerializableRO = \"SERIALIZABLE, READ ONLY\",\n  RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n  ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n  SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\n\nexport namespace TxnSatisfying {\n  export type Serializable = Isolation.Serializable;\n  export type RepeatableRead = Serializable | Isolation.RepeatableRead;\n  export type ReadCommitted = RepeatableRead | Isolation.ReadCommitted;\n  export type SerializableRO = Serializable | Isolation.SerializableRO;\n  export type RepeatableReadRO = SerializableRO | RepeatableRead | Isolation.RepeatableReadRO;\n  export type ReadCommittedRO = RepeatableReadRO | ReadCommitted | Isolation.ReadCommittedRO;\n  export type SerializableRODeferrable = SerializableRO | Isolation.SerializableRODeferrable;\n}\n\nexport interface TxnClient<T extends Isolation | undefined> extends pg.PoolClient {\n  transactionMode: T;\n}\n\nlet txnSeq = 0;\n\n/**\n * Provide a database client to the callback, whose queries are then wrapped in a \n * database transaction. The transaction is committed, retried, or rolled back as \n * appropriate. \n * @param pool The `pg.Pool` from which to check out the database client\n * @param isolationMode The `Isolation` mode (e.g `Serializable`) \n * @param callback The callback function that runs queries on the provided client\n */\nexport async function transaction<T, M extends Isolation>(\n  pool: pg.Pool,\n  isolationMode: M,\n  callback: (client: TxnClient<M>) => Promise<T>\n): Promise<T> {\n\n  const\n    txnId = txnSeq++,\n    txnClient = await pool.connect() as TxnClient<typeof isolationMode>,\n    config = getConfig(),\n    maxAttempts = config.transactionAttemptsMax,\n    { minMs, maxMs } = config.transactionRetryDelay;\n  \n  txnClient.transactionMode = isolationMode;\n\n  try {\n    for (let attempt = 1; ; attempt++) {\n      try {\n        if (attempt > 1) console.log(`Retrying transaction #${txnId}, attempt ${attempt} of ${maxAttempts}`);\n\n        await sql`START TRANSACTION ISOLATION LEVEL ${raw(isolationMode)}`.run(txnClient);\n        const result = await callback(txnClient);\n        await sql`COMMIT`.run(txnClient);\n\n        return result;\n\n      } catch (err) {\n        await sql`ROLLBACK`.run(txnClient);\n\n        // on trapping the following two rollback error codes, see:\n        // https://www.postgresql.org/message-id/1368066680.60649.YahooMailNeo@web162902.mail.bf1.yahoo.com\n        // this is also a good read:\n        // https://www.enterprisedb.com/blog/serializable-postgresql-11-and-beyond\n\n        if (isDatabaseError(err, \"TransactionRollback_SerializationFailure\", \"TransactionRollback_DeadlockDetected\")) {\n          if (attempt < maxAttempts) {\n            const delayBeforeRetry = Math.round(minMs + (maxMs - minMs) * Math.random());\n            console.log(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, retrying in ${delayBeforeRetry}ms`);\n            await wait(delayBeforeRetry);\n\n          } else {\n            console.log(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, giving up`);\n            throw err;\n          }\n\n        } else {\n          throw err;\n        }\n      }\n    }\n\n  } finally {\n    (txnClient as any).transactionMode = undefined;\n    txnClient.release();\n  }\n}\n", "zapatos/src/utils.ts": "import { Default } from './core';\n\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport const wait = (delayMs: number) => new Promise(resolve => setTimeout(resolve, delayMs));\n\n/**\n * Map an input array to an output array, interspersing a constant separator value \n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport const mapWithSeparator = <TIn, TSep, TOut>(\n  arr: TIn[],\n  separator: TSep,\n  cb: (x: TIn, i: number, a: typeof arr) => TOut\n): (TOut | TSep)[] => {\n\n  const result: (TOut | TSep)[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (i > 0) result.push(separator);\n    result.push(cb(arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets the value Default. \n * \n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: Default }, { x: Default, y: 2}]`\n * @param objs The array of objects\n */\nexport const completeKeysWithDefault = <T extends object>(objs: T[]): T[] => {\n  // \n  const unionKeys = Object.assign({}, ...objs);\n  for (let k in unionKeys) unionKeys[k] = Default;\n  return objs.map(o => Object.assign({}, unionKeys, o));\n};\n", "pg.ts": "\nexport interface Pool {}\nexport interface PoolClient {}\nexport interface QueryResult {\n  rows: any;\n}\n", "zapatos/src.ts": "\nexport * from './src/index';  // workaround\n", "pgPool.ts": "\nimport * as pg from 'pg';\nexport let pool: pg.Pool;\n" }
    ;

for (const file in files) monaco.languages.typescript.typescriptDefaults.addExtraLib(files[file], `file:///${file}`);

const js = 
`import * as db from './zapatos/src';
import * as s from './zapatos/schema';
import { pool } from './pgPool';

(async () => {

    // 1. Simple tools for writing raw SQL and manually applying types

    // (a) INSERT using cols and vals helpers
    const
      author: s.authors.Insertable = {
        name: 'Gabriel Garcia Marquez',
        isLiving: false,
      },
      [insertedAuthor] = await db.sql<s.authors.SQL, s.authors.Selectable[]>\`
          INSERT INTO \${ "authors" } (\${ db.cols(author) })
          VALUES(\${ db.vals(author) }) RETURNING * \`
        .run(pool);

    console.log(insertedAuthor.id);

    // (b) SELECT using a Whereable, self and (manual) param
    const 
      searchTerm = 'marquez',  // could be untrusted 
      likePattern = \`% \${ searchTerm }% \`,
      [foundAuthor] = await db.sql<s.authors.SQL, s.authors.Selectable[]>\`
        SELECT * FROM \${ "authors" } WHERE \${{
          isLiving: false,
          name: db.sql<db.SQL>\`\${db.self} ILIKE \${db.param(likePattern)}\`,
        }}\`
      .run(pool);
    
    console.log(foundAuthor?.name);


    // 2. Shortcut functions for generating bread-and-butter queries, automatically typed
    
    // (a) Multiple INSERT
    const insertedAuthors = await db.insert("authors", [
      { name: "Gabriel Garcia Marquez", isLiving: false }, 
      { name: "Douglas Adams", isLiving: false }
    ]).run(pool);

    // (b) Basic SELECT
    const books = await db.select('books', { authorId: 10 }).run(pool);
    books.map(b => b.title);


    // 3. Nestable select function, for arbitrarily complex LATERAL JOIN queries producing nested JSON structures, still automatically typed

    // (a) Nested SELECT with many-to-one (author) and many-to-many (tags) join
    const bookAuthorTags = await db.select('books', db.all, {
      lateral: {
        author: db.selectOne('authors', { id: db.parent('authorId') }),
        tags: db.select('tags', { bookId: db.parent('id') }),
      }
    }).run(pool);

    bookAuthorTags.map(b => b.author?.name);
    
    // (b) Nested SELECT two levels deep
    const authorsBooksTags = await db.select('authors', db.all, {
      lateral: {
        books: db.select('books', { authorId: db.parent('id') }, {
          lateral: {
            tags: db.select('tags', { bookId: db.parent('id') })
          }
        })
      }
    }).run(pool);

})();
`;

const model = monaco.editor.createModel(js, 'typescript', monaco.Uri.parse('file:///main.ts'));
monaco.languages.typescript.typescriptDefaults.setCompilerOptions({ strict: true });
monaco.editor.create(document.getElementById('container'), { model, minimap: { enabled: false } });
