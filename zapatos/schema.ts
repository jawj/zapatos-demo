/*
** DON'T EDIT THIS FILE **
It's been generated by Zapatos (v2.0.1), and is liable to be overwritten

Zapatos: https://jawj.github.io/zapatos/
Copyright (C) 2020 George MacKerron
Released under the MIT licence: see LICENCE file
*/

import * as db from './src/core';
import * as c from './custom';

type BasicWhereableFromInsertable<T> = { [K in keyof T]: Exclude<T[K] | db.ParentColumn, null | db.DefaultType> };
type WhereableFromBasicWhereable<T> = { [K in keyof T]?: T[K] | db.SQLFragment<any, T[K]> };
type WhereableFromInsertable<T> = WhereableFromBasicWhereable<BasicWhereableFromInsertable<T>>;

type UpdatableFromInsertable<T> = { [K in keyof T]?: T[K] | db.SQLFragment<any, T[K]> };

type JSONSelectableFromSelectable<T> = { [K in keyof T]:
  Date extends T[K] ? Exclude<T[K], Date> | db.DateString :
  Date[] extends T[K] ? Exclude<T[K], Date[]> | db.DateString[] :
  T[K]
};

/* === schema: extra === */

/* --- enums --- */


/* --- tables --- */

export declare namespace tableInOtherSchema {
  export type Table = 'tableInOtherSchema';
  export interface Selectable {
    id: number;
    details: string | null;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    details?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'tableInOtherSchema_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}


/* === schema: public === */

/* --- enums --- */

export type appleEnvironment = 'PROD' | 'Sandbox';
export declare namespace every {
  export type appleEnvironment = ['PROD', 'Sandbox'];
}

/* --- tables --- */

export declare namespace appleTransactions {
  export type Table = 'appleTransactions';
  export interface Selectable {
    environment: appleEnvironment;
    originalTransactionId: string;
    accountId: number;
    latestReceiptData: string | null;
  }
  export interface Insertable {
    environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;
    originalTransactionId: string | db.Parameter<string> | db.SQLFragment;
    accountId: number | db.Parameter<number> | db.SQLFragment;
    latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'appleTransPKey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace authors {
  export type Table = 'authors';
  export interface Selectable {
    id: number;
    name: string;
    isLiving: boolean | null;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    name: string | db.Parameter<string> | db.SQLFragment;
    isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'authors_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace bankAccounts {
  export type Table = 'bankAccounts';
  export interface Selectable {
    id: number;
    balance: number;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'bankAccounts_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace books {
  export type Table = 'books';
  export interface Selectable {
    id: number;
    authorId: number;
    title: string | null;
    createdAt: Date;
    updatedAt: Date;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    authorId: number | db.Parameter<number> | db.SQLFragment;
    title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
    createdAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment;
    updatedAt?: Date | db.Parameter<Date> | db.DateString | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'books_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace customTypes {
  export type Table = 'customTypes';
  export interface Selectable {
    id: number;
    structuredDocument: c.PgMySpecialJsonb | null;
    location: c.PgGeometry | null;
    otherLocation: c.PgMySpecialGeometry | null;
    furtherLocations: c.Pg_mySpecialGeometry | null;
    name: c.PgIllegal_characters_text | null;
    blah: c.PgContinue | null;
    bar: c.PgSQL | null;
    numbers: number[] | null;
    alsoName: c.PgSnake_cased_typename | null;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    structuredDocument?: c.PgMySpecialJsonb | db.Parameter<c.PgMySpecialJsonb> | null | db.DefaultType | db.SQLFragment;
    location?: c.PgGeometry | db.Parameter<c.PgGeometry> | null | db.DefaultType | db.SQLFragment;
    otherLocation?: c.PgMySpecialGeometry | db.Parameter<c.PgMySpecialGeometry> | null | db.DefaultType | db.SQLFragment;
    furtherLocations?: c.Pg_mySpecialGeometry | db.Parameter<c.Pg_mySpecialGeometry> | null | db.DefaultType | db.SQLFragment;
    name?: c.PgIllegal_characters_text | db.Parameter<c.PgIllegal_characters_text> | null | db.DefaultType | db.SQLFragment;
    blah?: c.PgContinue | db.Parameter<c.PgContinue> | null | db.DefaultType | db.SQLFragment;
    bar?: c.PgSQL | db.Parameter<c.PgSQL> | null | db.DefaultType | db.SQLFragment;
    numbers?: number[] | db.Parameter<number[]> | null | db.DefaultType | db.SQLFragment;
    alsoName?: c.PgSnake_cased_typename | db.Parameter<c.PgSnake_cased_typename> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'customTypes_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace emailAuthentication {
  export type Table = 'emailAuthentication';
  export interface Selectable {
    email: string;
    consecutiveFailedLogins: number;
    lastFailedLogin: Date | null;
  }
  export interface Insertable {
    email: string | db.Parameter<string> | db.SQLFragment;
    consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    lastFailedLogin?: Date | db.Parameter<Date> | db.DateString | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'emailAuthentication_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace employees {
  export type Table = 'employees';
  export interface Selectable {
    id: number;
    name: string;
    managerId: number | null;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    name: string | db.Parameter<string> | db.SQLFragment;
    managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'employees_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace identityTest {
  export type Table = 'identityTest';
  export interface Selectable {
    id: number;
    data: string | null;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    data?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'identityTest_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace stores {
  export type Table = 'stores';
  export interface Selectable {
    id: number;
    name: string;
    geom: c.PgGeometry;
  }
  export interface Insertable {
    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;
    name: string | db.Parameter<string> | db.SQLFragment;
    geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'stores_pkey';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

export declare namespace tags {
  export type Table = 'tags';
  export interface Selectable {
    tag: string;
    bookId: number;
  }
  export interface Insertable {
    tag: string | db.Parameter<string> | db.SQLFragment;
    bookId: number | db.Parameter<number> | db.SQLFragment;
  }
  export interface Updatable extends UpdatableFromInsertable<Insertable> { }
  export interface Whereable extends WhereableFromInsertable<Insertable> { }
  export interface JSONSelectable extends JSONSelectableFromSelectable<Selectable> { }
  export type UniqueIndex = 'tagsUniqueIdx';
  export type Column = keyof Selectable;
  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
  export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;
  export type SQL = SQLExpression | SQLExpression[];
}

/* === cross-table types === */

export type Table = appleTransactions.Table | authors.Table | bankAccounts.Table | books.Table | customTypes.Table | emailAuthentication.Table | employees.Table | identityTest.Table | stores.Table | tableInOtherSchema.Table | tags.Table;
export type Selectable = appleTransactions.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | customTypes.Selectable | emailAuthentication.Selectable | employees.Selectable | identityTest.Selectable | stores.Selectable | tableInOtherSchema.Selectable | tags.Selectable;
export type Whereable = appleTransactions.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | customTypes.Whereable | emailAuthentication.Whereable | employees.Whereable | identityTest.Whereable | stores.Whereable | tableInOtherSchema.Whereable | tags.Whereable;
export type Insertable = appleTransactions.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | customTypes.Insertable | emailAuthentication.Insertable | employees.Insertable | identityTest.Insertable | stores.Insertable | tableInOtherSchema.Insertable | tags.Insertable;
export type Updatable = appleTransactions.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | customTypes.Updatable | emailAuthentication.Updatable | employees.Updatable | identityTest.Updatable | stores.Updatable | tableInOtherSchema.Updatable | tags.Updatable;
export type UniqueIndex = appleTransactions.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | customTypes.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | identityTest.UniqueIndex | stores.UniqueIndex | tableInOtherSchema.UniqueIndex | tags.UniqueIndex;
export type Column = appleTransactions.Column | authors.Column | bankAccounts.Column | books.Column | customTypes.Column | emailAuthentication.Column | employees.Column | identityTest.Column | stores.Column | tableInOtherSchema.Column | tags.Column;
export type AllTables = [appleTransactions.Table, authors.Table, bankAccounts.Table, books.Table, customTypes.Table, emailAuthentication.Table, employees.Table, identityTest.Table, stores.Table, tableInOtherSchema.Table, tags.Table];


export type SelectableForTable<T extends Table> = {
  appleTransactions: appleTransactions.Selectable;
  authors: authors.Selectable;
  bankAccounts: bankAccounts.Selectable;
  books: books.Selectable;
  customTypes: customTypes.Selectable;
  emailAuthentication: emailAuthentication.Selectable;
  employees: employees.Selectable;
  identityTest: identityTest.Selectable;
  stores: stores.Selectable;
  tableInOtherSchema: tableInOtherSchema.Selectable;
  tags: tags.Selectable;
}[T];

export type WhereableForTable<T extends Table> = {
  appleTransactions: appleTransactions.Whereable;
  authors: authors.Whereable;
  bankAccounts: bankAccounts.Whereable;
  books: books.Whereable;
  customTypes: customTypes.Whereable;
  emailAuthentication: emailAuthentication.Whereable;
  employees: employees.Whereable;
  identityTest: identityTest.Whereable;
  stores: stores.Whereable;
  tableInOtherSchema: tableInOtherSchema.Whereable;
  tags: tags.Whereable;
}[T];

export type InsertableForTable<T extends Table> = {
  appleTransactions: appleTransactions.Insertable;
  authors: authors.Insertable;
  bankAccounts: bankAccounts.Insertable;
  books: books.Insertable;
  customTypes: customTypes.Insertable;
  emailAuthentication: emailAuthentication.Insertable;
  employees: employees.Insertable;
  identityTest: identityTest.Insertable;
  stores: stores.Insertable;
  tableInOtherSchema: tableInOtherSchema.Insertable;
  tags: tags.Insertable;
}[T];

export type UpdatableForTable<T extends Table> = {
  appleTransactions: appleTransactions.Updatable;
  authors: authors.Updatable;
  bankAccounts: bankAccounts.Updatable;
  books: books.Updatable;
  customTypes: customTypes.Updatable;
  emailAuthentication: emailAuthentication.Updatable;
  employees: employees.Updatable;
  identityTest: identityTest.Updatable;
  stores: stores.Updatable;
  tableInOtherSchema: tableInOtherSchema.Updatable;
  tags: tags.Updatable;
}[T];

export type UniqueIndexForTable<T extends Table> = {
  appleTransactions: appleTransactions.UniqueIndex;
  authors: authors.UniqueIndex;
  bankAccounts: bankAccounts.UniqueIndex;
  books: books.UniqueIndex;
  customTypes: customTypes.UniqueIndex;
  emailAuthentication: emailAuthentication.UniqueIndex;
  employees: employees.UniqueIndex;
  identityTest: identityTest.UniqueIndex;
  stores: stores.UniqueIndex;
  tableInOtherSchema: tableInOtherSchema.UniqueIndex;
  tags: tags.UniqueIndex;
}[T];

export type ColumnForTable<T extends Table> = {
  appleTransactions: appleTransactions.Column;
  authors: authors.Column;
  bankAccounts: bankAccounts.Column;
  books: books.Column;
  customTypes: customTypes.Column;
  emailAuthentication: emailAuthentication.Column;
  employees: employees.Column;
  identityTest: identityTest.Column;
  stores: stores.Column;
  tableInOtherSchema: tableInOtherSchema.Column;
  tags: tags.Column;
}[T];

export type SQLForTable<T extends Table> = {
  appleTransactions: appleTransactions.SQL;
  authors: authors.SQL;
  bankAccounts: bankAccounts.SQL;
  books: books.SQL;
  customTypes: customTypes.SQL;
  emailAuthentication: emailAuthentication.SQL;
  employees: employees.SQL;
  identityTest: identityTest.SQL;
  stores: stores.SQL;
  tableInOtherSchema: tableInOtherSchema.SQL;
  tags: tags.SQL;
}[T];

